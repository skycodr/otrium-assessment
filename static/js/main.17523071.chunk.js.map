{"version":3,"sources":["components/tree/Tree.tsx","components/leaf/Leaf.tsx","utils/index.ts","hooks/useFacets.ts","hooks/useTree.ts","contexts/TreeContext.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Branch","props","root","rootData","keyExtractor","rootExtractor","sourceExtractor","render","TreeItem","nodeId","id","label","map","datum","Tree","className","TreeView","defaultCollapseIcon","defaultExpandIcon","Leaf","checked","onChange","Box","Checkbox","data-testid","onClick","e","stopPropagation","_checked","getCategoryLabel","name","count","getCategoryKey","parent","getCategoryChildFacet","matcher","data","facet","isMatch","Object","entries","key","value","useFacets","sourceData","useState","dataSource","setSource","commitSource","useRef","getFacets","current","filter","setFacets","values","matchingSource","updateAll","keys","length","node","push","removeFacets","commit","mappedSource","undefined","useTree","context","childFacetExtractor","handleSelect","setNodeSelection","forEach","childNode","toggleSelectAll","handleDelete","TreeContext","createContext","_facet","_value","TreeContextProvider","children","json","categories","Provider","useTreeStyles","makeStyles","treeStyle","flexGrow","maxWidth","App","styles","useContext","Grid","direction","container","FormControlLabel","control","target","IconButton","aria-label","Delete","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.17523071.chunk.js","sourcesContent":["import ChevronRightIcon from '@material-ui/icons/ChevronRight';\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore';\nimport { TreeItem, TreeView } from \"@material-ui/lab\";\n\n/**\n * A recursive component which will render nested\n * items for the tree.\n * \n * @param props {IBranchProps}\n * @returns JSX.Element\n */\nconst Branch = <T extends ITreeData>(props: IBranchProps<T>) => {\n  const {\n    root,\n    rootData,\n    keyExtractor,\n    rootExtractor,\n    sourceExtractor,\n    render\n  } = props;\n\n  return (\n    <TreeItem nodeId={rootData.id} label={render(rootData)} >\n      {\n        (sourceExtractor?.(root) ?? []).map(datum =>\n          <Branch<T>\n            key={keyExtractor(datum)}\n            {...{ ...props, root: rootExtractor(datum), rootData: datum }}\n          />\n        )\n      }\n    </TreeItem >\n  );\n};\n\n/**\n * Tree component.\n *\n * @param props {ITreeData} ITreeData value.\n * @returns JSX.Element.\n */\nconst Tree = <T extends ITreeData>(props: ITreeProps<T>) => {\n\n  const {\n    root,\n    keyExtractor,\n    rootExtractor,\n    sourceExtractor,\n    className\n  } = props;\n\n  return (\n    <TreeView\n      className={className}\n      defaultCollapseIcon={<ExpandMoreIcon />}\n      defaultExpandIcon={<ChevronRightIcon />}\n    >\n      {\n        (sourceExtractor?.(root) ?? []).map((datum) =>\n          <Branch<T>\n            key={keyExtractor(datum)}\n            {...{ ...props, root: rootExtractor(datum), rootData: datum }}\n          />\n        )\n      }\n    </TreeView>\n  );\n\n}\n\nexport default Tree;\n","import { Box, Checkbox } from \"@material-ui/core\";\n\n/**\n * Component to render as the leaf node of a tree component\n * \n * @param {ILeafProps} props Properties used for the leaf component\n * @returns JSX.Element\n */\nconst Leaf = ({ id, label, checked = false, onChange }: ILeafProps) => (\n  <Box>\n    <Checkbox\n      data-testid={`treeItem_${id}`}\n      onClick={(e) => e.stopPropagation()}\n      onChange={(e, _checked) => onChange?.(e)}\n      checked={checked}\n    />\n    {label}\n  </Box>\n);\n\nexport default Leaf;\n","/**\r\n * Generates a label from a given ICategory object.\r\n *\r\n * @param {ICategory} param ICategory data.\r\n * @returns {string} A label string.\r\n */\r\nexport const getCategoryLabel = ({ name, count }: ICategory): string =>\r\n  `${name} (${count})`;\r\n\r\n/**\r\n * Generate a key property for given ICategory object.\r\n *\r\n * @param {ICategory} param ICategory data.\r\n * @returns {string} A key for ICategory.\r\n */\r\nexport const getCategoryKey = ({ id, parent }: ICategory): string =>\r\n  `${parent}_${id}`;\r\n\r\n/**\r\n * Generate a facet to retrieve a children for a given node\r\n *\r\n * @param param ITreeData object\r\n * @returns\r\n */\r\nexport const getCategoryChildFacet = ({\r\n  id,\r\n}: ICategory): Partial<ICategory> => ({\r\n  parent: id,\r\n});\r\n\r\n/**\r\n * Generate a facet for retrieving parent nodes\r\n * Todo: For future use\r\n *\r\n * @param param ITreeData object\r\n * @returns\r\n */\r\nexport const getCategoryParentFacet = ({\r\n  parent,\r\n}: ICategory): Partial<ICategory> => ({\r\n  id: parent,\r\n});\r\n\r\n// We don't need _ for just this function\r\nexport const isEmpty = <T extends object>(value: T) =>\r\n  !Object.keys(value).length;\r\n","import { useRef, useState } from 'react';\nimport { isEmpty } from '../utils';\n\n/**\n * Match a given ITreeData object with facet ITreeData object and return\n * true or false\n *\n * @param data ITreeData object that needs to be compared with teh facet\n * @param facet ITreeData object that\n * @returns True or false if exact match is found\n */\nconst matcher = <T extends ITreeData>(data: T, facet: Partial<T>) => {\n  // Todo: Performance deterrent. Move to calling function\n  const entries = Object.entries(facet);\n\n  let isMatch = true;\n\n  /*\n   * Get all key, value pairs in the facet. Check if every key value is a\n   * match in data if so return true. Even on a single property mismatch\n   * break from loop.\n   */\n  for (const [key, value] of entries) {\n    // Dev Note: isMatch &&= data[key] === value seem to crash.\n    isMatch = isMatch && data[key] === value;\n\n    if (!isMatch) {\n      break;\n    }\n  }\n\n  return isMatch;\n};\n\n/**\n * A custom hook to manipulate object facets in an array.\n * Allows get/set properties of an ITreeData object\n *\n * @param {ITreeData[]} sourceData A flat array of ITreeData objects\n * @returns {ITreeFacets}\n */\nconst useFacets = <T extends ITreeData>(sourceData: T[]): ITreeFacets<T> => {\n  const [dataSource, setSource] = useState<T[]>(sourceData);\n  const commitSource = useRef<T[] | undefined>();\n\n  /**\n   * Get matching facet data from the source\n   *\n   * @param {ITreeData} facet Object to lookup the source\n   * @returns\n   */\n  const getFacets = (facet: Partial<T>) =>\n    (commitSource.current ?? dataSource).filter((data) =>\n      matcher<T>(data, facet),\n    );\n\n  /**\n   * Set properties of a given object for a given facet\n   *\n   * @param {ITreeData} facet Partial facet object lookup the source\n   * @param {ITreeData} values Partial value facet object to be set in  on matching facets\n   *\n   * @returns Matching nodes\n   */\n  const setFacets = (facet: Partial<T>, values: Partial<T>) => {\n    // If a commit source is available use the commit source.\n    // Else use the source as the mapped source.\n    const matchingSource: T[] = [];\n\n    // If facets are not available. Assume all values\n    // needs to be updated.\n    const updateAll = isEmpty(facet);\n\n    commitSource.current = (commitSource.current ?? dataSource).map((value) => {\n      let node = { ...value };\n      if (updateAll || matcher<T>(value, facet)) {\n        node = { ...node, ...values };\n        matchingSource.push(node);\n      }\n\n      return node;\n    });\n\n    return matchingSource;\n  };\n\n  const removeFacets = (facet: Partial<T>) => {\n    commitSource.current = (commitSource.current ?? dataSource).filter(\n      (value) => !matcher<T>(value, facet),\n    );\n  };\n\n  /**\n   * Commit any updates to the source data. This act as a\n   * batch update. This was introduced for performance reasons.\n   */\n  const commit = () => {\n    if (!!commitSource.current) {\n      const mappedSource = [...commitSource.current];\n      commitSource.current = undefined;\n      setSource(mappedSource);\n    }\n  };\n\n  return {\n    dataSource,\n    getFacets,\n    setFacets,\n    removeFacets,\n    commit,\n  };\n};\n\nexport default useFacets;\n","/**\n * Custom hook provide the Tree with accompanying methods and data.\n *\n * Dev Note:\n *  This solution in not as generic as I would like it to be. As the hook\n *  is coupled to the context API. Ideally, I would pass required methods\n *  to deal with the necessities and have a wrapper to inject data so it is\n *  generic enough to handle all sort of scenarios.\n *\n * @param {ITreeFacets} context ITreeFacets object which is the data source\n * @param childFacetExtractor\n * @returns\n */\nconst useTree = <T extends ITreeData>(\n  context: ITreeFacets<T>,\n  childFacetExtractor: TFunction<T, Partial<T>>,\n): TUseTree<T> => {\n  const { getFacets, setFacets, removeFacets, commit } = context;\n\n  /*\n   * Handle checkbox change event. Create the value to set, update current node\n   * and descendant nodes with the value and commit changes.\n   *\n   * Todo:\n   *  Find the ancestors and move to indeterminate sate if necessary. This should\n   *  be a conditional state. I.e: if the parent node is selected and at least one\n   *  of its descendant is unselected it should move to this state. This should be\n   *  a bit process intensive as each ancestral node's descendant node needs to be\n   *  traversed.\n   */\n\n  const handleSelect: TTreeCheckboxChangeHandler<T> = (datum: T, checked) => {\n    const value = { checked } as Partial<T>;\n\n    const setNodeSelection = (node: T) => {\n      setFacets(node, value);\n      setFacets(childFacetExtractor(node), value).forEach((childNode) =>\n        setNodeSelection(childNode),\n      );\n    };\n\n    setNodeSelection(datum);\n    commit();\n  };\n\n  /*\n   * Handle toggle select all\n   */\n  const toggleSelectAll = (checked: boolean) => {\n    setFacets({}, { checked } as Partial<T>);\n    commit();\n  };\n\n  /*\n   * Handle delete selected items\n   */\n  const handleDelete = () => {\n    removeFacets({ checked: true } as Partial<T>);\n    commit();\n  };\n\n  return {\n    handleSelect,\n    toggleSelectAll,\n    handleDelete,\n    getFacets,\n  };\n};\n\nexport default useTree;\n","import { createContext } from \"react\";\nimport { useFacets } from \"../hooks\";\n\nimport json from '../__data__/categories.json';\n\n// Context Object\nexport const TreeContext = createContext<ITreeFacets<ICategory>>({\n  dataSource: [],\n  getFacets: (_facet) => [],\n  setFacets: (_facet, _value) => [],\n  removeFacets: (_facet) => { },\n  commit: () => { }\n});\n\n// Context Provider\nconst TreeContextProvider = ({ children }: IChildren) => {\n  const {\n    dataSource,\n    getFacets,\n    setFacets,\n    removeFacets,\n    commit\n  } = useFacets<ICategory>(json.data.categories);\n\n  return (\n    <TreeContext.Provider value={{ dataSource, getFacets, setFacets, removeFacets, commit }}>\n      {children}\n    </TreeContext.Provider>\n  );\n};\n\nexport default TreeContextProvider;","import { Checkbox, FormControlLabel, Grid, IconButton, makeStyles } from '@material-ui/core';\nimport { Delete } from '@material-ui/icons';\nimport { useContext } from 'react';\nimport { Leaf, Tree } from './components';\nimport { TreeContext } from './contexts';\nimport { useTree } from './hooks';\nimport { getCategoryKey, getCategoryLabel, getCategoryChildFacet } from './utils';\n\nconst useTreeStyles = makeStyles({\n  treeStyle: {\n    flexGrow: 1,\n    maxWidth: 400,\n  },\n});\n\nconst App = () => {\n  const styles = useTreeStyles();\n  const {\n    getFacets,\n    handleSelect,\n    handleDelete,\n    toggleSelectAll\n  } = useTree<ICategory>(useContext(TreeContext), getCategoryChildFacet);\n\n  /**\n   * Special Note:\n   * \n   * If you want to get all selected categories. Simply write,\n   *  getNodes({checked: true});\n   */\n\n  /*\n   * Dev Note:\n   *\n   *  I have written some confusing logic on purpose. :D. Normally wouldn't do this\n   *  on a project. Such as, bunching up things together without first using variables etc.\n   */\n\n  return (\n    <Grid direction='column' container>\n      <Grid>\n        <FormControlLabel\n          label='Toggle select all'\n          control={\n            <Checkbox\n              data-testid='selectAll'\n              onChange={(e) => toggleSelectAll(e.target.checked)}\n            />\n          }\n        />\n        <IconButton aria-label=\"delete\" onClick={handleDelete}>\n          <Delete />\n        </IconButton>\n      </Grid>\n      <Grid>\n        <Tree<ICategory>\n          data-testid='treeMenu'\n          className={styles.treeStyle}\n          root={{ parent: '0' }}\n          sourceExtractor={getFacets}\n          keyExtractor={getCategoryKey}\n          rootExtractor={getCategoryChildFacet}\n          // You may find branches are on the tree ;)\n          render={(value: ICategory) => (\n            <Leaf id={value.id} label={getCategoryLabel(value)} onChange={(e) => {\n              e.stopPropagation();\n              handleSelect(value, e.target.checked);\n            }} checked={!!value.checked} />\n          )}\n        />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport { TreeContextProvider } from './contexts';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <TreeContextProvider>\n      <App />\n    </TreeContextProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}